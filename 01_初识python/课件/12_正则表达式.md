## 1.正则表达式使用
导入依赖包re。

## 2.常用的方法
### 2.1.正则表达式匹配
match()：仅从字符串的‌开头‌开始匹配，若开头不满足正则表达式则返回None。
search()：扫描‌整个字符串‌，返回第一个匹配到的结果，无论位置如何。
findall(): 提取所有满足正则的结果并封装为列表返回。
finditer(): 提取所有满足正则的结果的迭代器，可在循环时输出匹配的位置信息等。

## 3.常见匹配规则
- `.`    :  匹配除换行符以外的任意字符
- `\w`   :  匹配字母或数字或下划线或汉字
- `\s`   :  匹配任意的空白符
- `\d`   :  匹配数字
- `\b`   :  匹配单词的开始或结束
- `^`    :  匹配字符串的开始
- `$`    :  匹配字符串的结束
- `*`  :  重复零次或更多次
- `+`  :  重复一次或更多次
- `?`    :  重复零次或一次
- `{n}`  :  重复n次
- `{n,}` :  重复n次或更多次
- `{n,m}`:  重复n到m次
- `\W`   : 匹配任意不是字母，数字，下划线，汉字的字符
- `\S`   : 匹配任意不是空白符的字符
- `\D`   : 匹配任意非数字的字符
- `\B`   : 匹配不是单词的开头或结束的位置
- `[^x]` : 匹配除了x以外的任意字符
- `[^ae]`: 匹配除了ae这几个字母以外的任意字符
- `|`    : 分支条件。匹配分支条件时，将会从左往右地测试每个条件，如果满足了某个分支条件的话，就不会去管其它的条件了
- `()`   : 分组

## 4.进阶使用
### 4.1.捕获
- `(exp)`        : 匹配exp， 并捕获文本到自动命名的组里
- `(?<name>exp)` : 匹配exp，并捕获文本到名称为name的组里，也可以写成`(?'name'exp)`, eg.`(?P<pw>\w+)`
- `(?:exp)`      : 匹配exp， 不捕获匹配的文本，也不给此分组分配组号
### 4.2.零宽断言
像`\b`, `^`, `$`那样用于指定一个位置， 这个位置应该满足一定的条件（即断言），因此它们也被成为零宽断言。
- `(?=exp)`   : 匹配exp前面的位置
- `(?<=exp)`  : 匹配exp后面的位置
- `(?!exp)`   : 匹配后面跟的不是exp的位置
- `(?<!exp)`  : 匹配前面不是exp的位置
### 4.3.注释
- `(?#comment)` : 这种类型的分组不对正则表达式的处理产生任何影响，用于提供注释让人阅读
